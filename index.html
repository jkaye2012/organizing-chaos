<!DOCTYPE html>
<html lang="en-us">
<head>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta name="generator" content="Hugo 0.92.2" />
	
	<title>Organizing Chaos - Thoughts on software and technical leadership</title>

	
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto">
	<link href="https://jkaye2012.github.io/css/bootstrap.min.css" rel="stylesheet">
	<link href="https://jkaye2012.github.io/css/strange-case.css" rel="stylesheet">
	

	
	
	<!--[if lt IE 9]>
	<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
	<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
	<![endif]-->

	
	<link href="/index.xml" rel="alternate" type="application/rss+xml" title="Organizing Chaos" />
</head>
<body class="scheme-darkbrown">


<div class="container-fluid">
  <div class="row">
    <div class="col-md-3 d-none d-md-block sidebar">
      
	<div class="sidebar-content">

		<a href="https://jkaye2012.github.io"><h1>Organizing Chaos</h1></a>
		<p>Thoughts on software and technical leadership</p>

		

		<ul class="sidebar-menus sidebar-icons">
                  
                    <li><a href="https://github.com/jkaye2012"><img src="/images/github.png"></img></a></li>
                  
                    <li><a href="https://www.linkedin.com/in/jordan-kaye-8bb64537/"><img width="32px" height="32px" src="/images/linkedin.png"></img></a></li>
                  
                </ul>

		<ul class="sidebar-menus">
                  
                    <li>&#187; <a href="/about">About me</a></li>
                  
                </ul>

		<div class="sidebar-recent hidden-xs">
                  <p>Recent Posts:</p>
                  <ul>
                    
                      <li><a href="https://jkaye2012.github.io/posts/go-slow-move-fast/">Go slow to move fast</a></li>
                    
                      <li><a href="https://jkaye2012.github.io/posts/striped-development/">Striped development</a></li>
                    
                      <li><a href="https://jkaye2012.github.io/posts/blog-genesis/">Creating a development blog</a></li>
                    
                  </ul>
                </div>

		

		<p class="copyright">&copy; 2023. All rights reserved. </p>
		<p class="attr">Powered by <a href="http://gohugo.io">Hugo</a> &amp; <a href="https://github.com/ExchangeRate-API/strange-case">Strange Case</a> (inspired by <a href="https://github.com/poole/hyde">Hyde</a>).</p>

	</div>

    </div>
    <div class="col-md-9 ml-sm-auto col-lg-9 pt-3 px-4" role="main">
      
      <div class="post">
        <div class="post-heading">
          <h1><a href="https://jkaye2012.github.io/posts/go-slow-move-fast/">Go slow to move fast</a></h1>
          <span>Mar 18, 2023</span>
        </div>
        
<hr />
<figure class="text-center">
  <blockquote class="blockquote">
    <p class="font-italic">
      
Engineering teams can often improve their long-term development velocity by slowing down in the short term

    </p>
  </blockquote>
</figure>
<hr />

<h2 id="a-shared-misunderstanding">A shared misunderstanding</h2>
<p>Technical debt is an often debated topic. Like most concepts in software, it isn&rsquo;t particularly difficult to find
arguments supporting opposite sides of the spectrum - in a single minute of searching I was able to find that some
believe that <a href="https://thehftguy.com/2020/08/26/technical-debt-doesnt-exist/">technical debt doesn&rsquo;t exist</a>, while others
feel that <a href="https://www.forbes.com/sites/forbestechcouncil/2022/05/09/technical-debt-the-most-important-concept-of-product-development/?sh=33c6b36792b4">technical debt is the most important aspect of product
development</a>.
From the conversations that I&rsquo;ve had with others in the industry, both within my place of work and with technical
leaders from other companies, I&rsquo;ve come to believe that one of the root causes of the gap between these viewpoints is
primarily definitional.</p>
<p>Part of the reason that some people don&rsquo;t like the term &ldquo;technical debt&rdquo; is that they feel it becomes an excuse. To
these individuals, everything that software engineers don&rsquo;t like within the system on which they&rsquo;re working gets labeled
as debt, and that debt becomes a boogeyman that gets blamed for all of their problems. Those on the other side of the
argument feel almost the exact opposite: technical debt gets little attention and they&rsquo;re forced to spend inordinate
amounts of time struggling against implementations and concepts that make it more difficult to make changes than it
otherwise could be. An interesting realization (and something that makes this conversation particularly difficult) is
that <em>both groups can be right at the same time</em>. This can be true only because the two groups are misunderstanding one
another. But where does this misunderstanding come from?</p>
<p>The phrase &ldquo;technical debt&rdquo; was originally coined by <a href="https://en.wikipedia.org/wiki/Ward_Cunningham">Ward Cunningham</a>,
one of the co-authors of the Agile Manifesto. He since <a href="http://wiki.c2.com/?WardExplainsDebtMetaphor">explained what he meant when he originated the
term</a>. Two excerpts from his explanation are particularly important to the
ideas that I want to discuss:</p>
<blockquote>
<p>With borrowed money you can do something sooner than you might otherwise, but then until you pay back that money
you&rsquo;ll be paying interest. I thought borrowing money was a good idea, I thought that rushing software out the door to
get some experience with it was a good idea, but that of course, you would eventually go back and as you learned
things about that software you would repay that loan by refactoring the program to reflect your experience as you
acquired it.</p>
<p>You know, if you want to be able to go into debt that way by developing software that you don&rsquo;t
completely understand, you are wise to make that software reflect your understanding as best as you can, so that when
it does come time to refactor, it&rsquo;s clear what you were thinking when you wrote it, making it easier to refactor it
into what your current thinking is now. In other words, the whole debt metaphor, let&rsquo;s say, the ability to pay back
debt, and make the debt metaphor work for your advantage depends upon your writing code that is clean enough to be
able to refactor as you come to understand your problem.</p>
</blockquote>
<p>From Ward&rsquo;s explanation, we learn that technical debt doesn&rsquo;t mean &ldquo;poorly written code&rdquo; or &ldquo;implementation in the
system that annoys developers&rdquo;; rather, it implies a <em>choice</em> that was made in the past. There is never any excuse for
writing &ldquo;bad&rdquo; code, but there is a time and a place to make sub-optimal decisions during product development in order to
shorten time to initial delivery. The longer those sub-optimal decisions are allowed to persist within the system, the
larger their negative impact.</p>
<p>The misunderstanding between the two camps is caused at least in part by the fact that debt is so often associated with
anything that an engineering team perceives to slow them down. I believe this situation is inevitable with any post-hoc
debt classification strategy, and therefore should be avoided in lieu of more effective options.</p>
<h2 id="technical-debt-should-be-intentional">Technical debt should be intentional</h2>
<p>I believe that technical debt is most useful as a concept when it&rsquo;s thought of as something that&rsquo;s taken on <em>knowingly</em>.
If we think about taking the debt metaphor literally, this is also the definition that seems to make the most sense
considering that financial debt isn&rsquo;t something that can happen to someone without their knowledge. When we take on
financial debt, we&rsquo;re accepting a greater total payment over time in order to buy something that we wouldn&rsquo;t otherwise
be able to afford in the present. Just so with technical debt, except now the concern is with development time rather
than money: we&rsquo;re accepting a greater amount of total development time over the lifetime of the product in exchange for
a faster initial delivery.</p>
<p>One of the great things about attaching a requirement of knowledge to technical debt is that it automatically solves
problems on both side of the misunderstanding presented earlier:</p>
<ul>
<li>It provides much better visibility into the amount of debt that&rsquo;s been taken on in order to build a product, and how
much of that debt hasn&rsquo;t been paid down</li>
<li>Debt can&rsquo;t be overinflated or understated because it&rsquo;s classified at the time that it&rsquo;s taken on rather than
retroactively</li>
<li>The difference between routine maintenance and debt pay-down is clear; maintenance is work that must be done that is
neither classified as debt nor as an enhancement/feature of the product</li>
<li>Because debt is explicitly classified, it can be prioritized against other types of work intentionally</li>
</ul>
<p>It also allows teams, product managers, and stakeholders to have more informed and well-reasoned discussions about their
product throughout the development process. Developers and team leads should be able to clearly communicate when debt is
being taken on in order to hit a deadline, product managers gain the ability to clearly see debt growing in the
product&rsquo;s backlog, and stakeholders can work with both groups to make well-reasoned decisions about when the team should
push for new functionality and when it makes more sense to work on insufficient foundations.</p>
<p>It can be difficult for PMs and non-technical stakeholders to truly understand the long-term impact of technical debt,
but I have seen this method work in practice by implementing it myself. I believe the most important key to unlocking
these benefits is <em>shared understanding</em>. When working with the idea of debt in this way, it becomes very easy for
developers to answer the question &ldquo;What is technical debt?&rdquo; and explain how these past decisions add up to make future
development more difficult.</p>
<p>Of course, none of this comes for free. For such a system to work to its fullest, it has to be adopted very early in the
product development process, ideally from the initial onset of the project. It requires building the shared
understanding between developers and non-technical personnel of what debt means and why it&rsquo;s important to pay attention
to. It requires at least a baseline level of buy-in from an organization that overall system quality is important to the
bottom line. None of these tasks are trivial, but neither are they difficult, and I believe the effort is well worth the
payoff.</p>
<h2 id="real-world-example">Real world example</h2>
<p>As a more concrete demonstration of what these ideas look like, I&rsquo;ve pulled some high-level data from one of my teams'
most recent deliveries. Here is that team&rsquo;s 6-month debt trend:</p>


<img  src="/images/go-slow-debt.png"   title="We use this data to inform our SDLC"  />

<p />

<p>Q4 was a &ldquo;push&rdquo; quarter for this team - they were working hard to hit a very specific deadline. During this time, they
made the decision that accruing a significant amount of debt was the only way that they were going to be able to make it
happen. After the team successfully hit the deadline, they were then able to revert to a more sustainable mode of
development; throughout Q1, they paid down a large portion of the debt that they had built up during the push.</p>
<p>Crucially, we were able to use the data available from this methodology as an aid to explain the importance of this work
to stakeholders and help them understand why short-term velocity on further functionality for the system would be
reduced while a portion of development time was spent paying down this debt.</p>
<p>I found it interesting to compare this trend to the ideal debt charts put forth in <a href="https://blog.crisp.se/2013/10/11/henrikkniberg/good-and-bad-technical-debt">yet another blog post about technical
debt</a>. Here&rsquo;s an idealized chart compared
to the team&rsquo;s debt baseline and ceiling:</p>
<p>

<img  src="/images/go-slow-ideal.png"   title="Idealized debt"  />

<p />



<img  src="/images/go-slow-overlay.png"   title="Baseline and ceiling in action"  />

<p />
</p>
<p>We can see that the debt management may not be completely ideal, but the team has been able to successfully pay their
debt down throughout the course of a quarter and are once again much closer to their debt baseline than they are to
their ceiling.</p>
<h2 id="slow-is-smooth-smooth-is-fast">Slow is smooth, smooth is fast</h2>
<p>Following these ideas, one of the mantras that I use with all of my development teams is &ldquo;We have to go slow if we want
to move fast&rdquo;. It sounds a bit silly perhaps, but I like sayings that will stick with people and the idea is simple:
slowing down gives us more time to think, more time to think leads to better designs, and better designs lend themselves
to easier change in the future. There are many situations where incurring debt makes sense, but there are at least as
many (and, I suspect, likely many more) where the best way to pay down debt is to never take it on at all. When we do
need to incur debt, we should do so intentionally and with at least some level of understanding of when and how we plan
to pay that debt down.</p>
<p>I particularly like this saying because it also has applications to many other areas of the development and leadership
process outside of technical debt specifically. Let&rsquo;s consider a contrived example, based on a true story:</p>
<p>A defect has been found in a production system that the team believes is being caused somehow due to the distributed
nature of the system. Two engineers separately attempt to identify the root cause of the issue, but are unable to find
the source of the problem after a week of investigation. A third engineer is brought in and is able to identify and
resolve the issue within a few days.</p>
<p>The first thought a lead may have is to increase their reliance on that third engineer, always bringing them in to
triage issues when they arise. The idea seems reasonable; after all, that engineer has proven that they can be much more
effective when it comes to issue resolution than the others. If, however, we take a longer-term view of the situation, I
believe this wouldn&rsquo;t be the best solution for at least two reasons:</p>
<ol>
<li>We&rsquo;ve introduced a single point of failure. If that engineer leaves the team or the company, we&rsquo;ll be right back to
struggling with issues</li>
<li>We&rsquo;re assuming that identifying and resolving these issues is the most valuable thing that the third engineer could
be doing. It&rsquo;s very possible that the opportunity cost of assigning them to triage is higher than the cost of the
defect</li>
</ol>
<p>With these failure modes in mind, it may make more sense to ask the third engineer to train the other engineers on their
issue resolution methodology. Future issues should be resolved by other engineers before enlisting the help of the
third, bringing them in only when the rest of the team is stumped (or perhaps has reached a predefined time-box).</p>
<p>While the latter is very likely to lead to longer issue resolution times in the short term, these times are also likely
to decrease as the other engineers gain familiarity and proficiency with the issue resolution process. Once we&rsquo;ve
reached that point, we now have three engineers capable of this type of issue resolution instead of only one. We made
the intentional decision to allow progress to be slower in the short term in order to effectively triple our longer term
velocity/capacity for this type of work.</p>
<h2 id="conclusion">Conclusion</h2>
<p>There&rsquo;s isn&rsquo;t a universal answer to the best way to balance development velocity against technical debt. Thinking of
debt as something taken on intentionally by a team to increase their short-term velocity at the expense of future work
is an easy to apply strategy that has many benefits to engineering teams while also simplifying the concept for less
technical individuals. By measuring accrued debt against long-term baselines and ceilings, engineering managers can get
a feel for how much this debt is impacting their teams, and this data can be used to aid in prioritization decisions and
high-level discussions with stakeholders.</p>
<p>If your goal to to increase your teams' overall development velocity in the long term, remember that you may want to
slow down so that you can move fast.</p>

      </div>
      
      <div class="post">
        <div class="post-heading">
          <h1><a href="https://jkaye2012.github.io/about/">Introduction</a></h1>
          <span>Oct 1, 2022</span>
        </div>
        
<div id="outline-container-headline-1" class="outline-2">
<h2 id="headline-1">
Background
</h2>
<div id="outline-text-headline-1" class="outline-text-2">
<p>
  My name is Jordan Kaye. I&#39;m currently the Head of Technology for <a href="http://www.belvederetrading.com">Belvedere Trading</a>&#39;s office in Boulder, focused on research and development
  of fully automated market-making systems.</p>
<p>
  As a leader, I believe that maintaining trust through honesty and consistent expectations is key to building high-performing teams and organizations.</p>
<p>
  As a technologist, I enjoy exploring different programming languages and paradigms to design robust and easily maintainable systems. I believe
  that embracing many different languages (and their corresponding communities) is a great way to expand one&#39;s knowledge
  and understanding of software.</p>
<p>
  When I&#39;m not working or writing code, I love lifting weights, skiing, hiking, and gaming.</p>
</div>
</div>
<div id="outline-container-headline-2" class="outline-2">
<h2 id="headline-2">
Contact
</h2>
<div id="outline-text-headline-2" class="outline-text-2">
<p>
  I&#39;m always happy to hear from other technology enthusiasts. The best way to reach me is though <a href="mailto:jkaye@belvederetrading.com">my work address</a>.</p>
<p>
  If you&#39;re a recruiter, I&#39;m not currently looking for work, but you can feel free to connect with me on LinkedIn via the link on the sidebar.</p>
</div>
</div>

      </div>
      
      <div class="post">
        <div class="post-heading">
          <h1><a href="https://jkaye2012.github.io/posts/striped-development/">Striped development</a></h1>
          <span>Oct 1, 2022</span>
        </div>
        
<hr />
<figure class="text-center">
  <blockquote class="blockquote">
    <p class="font-italic">
      
Incremental progress on large projects can be achieved by developing functional stripes across the system's components

    </p>
  </blockquote>
</figure>
<hr />

<p>When planning the delivery of a software project, there are many different strategies for handling the design and implementation
of the system. At the extremes, we could attempt to complete a fully-specified design before writing any code at all, or we could start
writing code without putting any thought towards our design and architecture at all. Most engineers would prefer not to live at either of
these extremes, so how can we do better?</p>
<p>System design is a fundamentally complex and difficult task, at least in part because our knowledge and experience is finite.
Unless we have a significant amount of experience building a <em>very</em> similar system, it&rsquo;s likely that at least some portion of our
prior experience won&rsquo;t translate directly to the results that we expect when applied to the new system. In general, we&rsquo;re unlikely to be able to
generate a completely correct or optimal system design without investing an extreme amount of time and effort up front.</p>
<p>With this in mind, we should normally prefer a highly iterative design and implementation strategy. There are many benefits to iterative processes in software development:
they allow us to incrementally modify our designs with new knowledge and experience that we&rsquo;ve gained from the existing implementation, provide
a sense of impact and motivation with each release, and allow us to deploy more frequently to learn and collect feedback from users.</p>
<p>One such strategy that I have found enjoyable and effective for both personal and professional projects I like to call striped development.
I was motivated to write this post after reading <a href="https://borretti.me/article/lessons-writing-compiler">an article about writing a compiler</a> that begins
by describing the author&rsquo;s implementation strategy, which is very similar to the striped development concept that I&rsquo;ve been using for many years now.</p>

<hr />
<aside>
  <div class="alert alert-light" role="alert">
    
I'm sure that there's another name and existing literature for this strategy, but I haven't been able to find it. Please let me know if you
have further reading that I could take a look at!

  </div>
</aside>
<hr />

<h2 id="definition">Definition</h2>
<p>Software systems can be thought of as a set of components that interact with each other to provide some externally visible functionality.
Each system-level component can itself be composed of other components; while these inner components will usually not be externally visible,
these properties of composition and encapsulation is integral to how we often think about designing and implementing software.
The <a href="https://c4model.com/">C4 model</a>, for example, attempts to formalize these ideas into a diagramming and documentation framework (quite successfully, in my opinion).</p>
<p>Striped development is an iterative approach to organizing work that embraces this fractal approach to system design and implementation
by way of three repeating phases:</p>
<ol>
<li><strong>Design</strong>: generate a high-level design for the components that comprise the system</li>
<li><strong>Striping</strong>: decide upon functionally-complete stripes that cut across those components</li>
<li><strong>Implementation</strong>: implement each stripe in turn, returning to the first step after each stripe to update the design and striping with any new
information gained from the implementation</li>
</ol>
<p>The most important part of this strategy is the circular nature of the phases. When we complete an implementation phase, we&rsquo;re not done; rather, this
simply means that it&rsquo;s time for us to return to the design phase where we can continue to improve upon the structure of the system as a whole:</p>

<hr />
<img  src="/images/striped-dev-phases.png"   title="Iteration is a continuous process"  />
<hr />
<p />

<p>Before the end of the post I&rsquo;ll go through a complete example of how this looks in practice, but it&rsquo;s first useful to understand each of the individual
phases in slightly more depth.</p>
<h3 id="design">Design</h3>
<p>System design in general is a deep topic, certainly much too deep to be reasonably explained in a short post such as this.
We can approach the design phase in many ways, but when working with striped development, I often like to think of it as a three-step process:</p>
<ol>
<li>Decide which components our system requires</li>
<li>Define the dependencies between those components</li>
<li>Optionally, specify the API boundary (data structures and operations) for each dependency
<ul>
<li>This third step generally becomes more useful further into the project when the system components and concepts have begun to stabilize</li>
</ul>
</li>
</ol>
<p>At first glance, the design phase may sound a bit like some classic advice:</p>


<img  src="/images/striped-dev-owl.jpg"   title="It&#39;s just that easy"  />

<p />

<p>If we already know how to generate a high-level design for the components that comprise the system and how they interact, why do we need this development methodology at all?
Can&rsquo;t we just take our design, implement it, and move on?</p>
<p>The key insight is that the design we generate when we first start the development process is likely to look quite different from the design when we&rsquo;re
finished. We could try to fight this idea with more planning, more information gathering, or more in-depth requirement specification, but in practice it&rsquo;s usually
much easier (and more effective) to embrace it. At each pass through the striped development process, rather than trying to create a fully specified,
completely correct, or perfectly optimized design, we are somewhat freed by the knowledge that we&rsquo;ll be returning to the design phase upon completion of each implementation phase.</p>
<p>Thus, the initial design phase is really about giving ourselves a reasonable starting point. Subsequent design phases improve upon the existing design,
ultimately converging upon an overall system structure that makes it easy to quickly modify system behavior. This is another benefit of the striping methodology: by
repeatedly modifying stripes through the entire system architecture, we quickly learn of deficiencies in our existing design. Whenever we run into trouble modifying
one of our sub-components or find it difficult to implement a new concept into the system, we&rsquo;ve identified an area that we can improve the way that our system is
structured.</p>
<h3 id="striping">Striping</h3>
<p>Striping is the determination of functional cross-sections that can be implemented across the current iteration of the system design. Choosing stripes
can often be the most difficult part of applying striped development; often, it&rsquo;s not readily apparent how we can structure our changes so that they
cut through the entire system end-to-end. Further, we should attempt to select stripes that will teach us as much as possible about our design and how
the system&rsquo;s components work together. This usually means selecting stripes in groups that build upon each other in some way.
If we choose three stripes that are almost entirely orthogonal in their functionality, it&rsquo;s possible that we could implement all three
without identifying a critical oversight in the design of our component interactions.</p>
<p>When striping, there&rsquo;s a balance to be struck: selecting more stripes up front will give you a better idea of what the overall development process will look like,
but also makes it more likely that some of the stripes may have to be changed (or removed entirely) as the structure of the system evolves.
In my experience, somewhere between three and five stripes tends to be a good balance, but ultimately this will depend on the perceived certainty/stability of the
design and your ability to effectively implement it.</p>
<h3 id="implementation">Implementation</h3>
<p>Implementation is the fun part! Here, we begin work on the next selected stripe and implement it to completion.
Usually, I prefer for stripe implementation to include all aspects of &ldquo;production quality&rdquo; code, including:</p>
<ul>
<li>Tests</li>
<li>Documentation</li>
<li>Resolution of all warnings and linting violations</li>
<li>Etc.</li>
</ul>
<p>While it&rsquo;s true that some of this effort is likely to be wasted (as not all implemented code will make it to our final version due to how quickly we&rsquo;ll be iterating),
working with complete implementations from the beginning of the development process makes it much easier to understand how working
with the system is going to feel once it&rsquo;s complete. If we try to blast through implementation phases as quickly as possible without cleaning up after ourselves,
we may reach a point where we find that implementing reasonable tests is very difficult or that our system is hard to explain with written documentation. These are
clear signs that complexity has not been properly managed.</p>
<p>In the short term, it may feel like doing all of this is slowing you down. If we&rsquo;re talking about amount accomplished in a few days, this is most likely true; however,
as I&rsquo;ll be addressing in <a href="/posts/go-slow-move-fast/">Go Slow to Move Fast</a> next month, over a longer period of time, keeping up with these basic
maintenance and quality activities will probably <em>increase</em> your total velocity over the same time period. It&rsquo;s counter-intuitive, but give it a try and see if it
holds true for you as it does for me.</p>
<p>As we&rsquo;ve alluded to in earlier sections, completing the implementation phase fully has two primary benefits:</p>
<h4 id="we-frequently-deploy-functionally-complete-changes-to-our-users">We frequently deploy functionally complete changes to our users</h4>
<p>Deploying changes to users is useful for many reasons. First and foremost, it allows us to collect feedback from the users. This is vital to overall project success.
As the authors and creators of a system, we see each feature and idiosyncrasy through a vastly different lens than anyone who wasn&rsquo;t involved in the development
process. We like to think that we can be impartial judges of our own work, but more often than not, this proves to be nearly impossible. Even if the system is not
yet complete (as it won&rsquo;t be for most of the development process), users can still provide us with valuable insight that we are completely blind to without the
un-invested observer to point it out to us.</p>
<p>Secondarily, deploying often is also a great motivating factor for the developers of the project. Whether it&rsquo;s a hobby project that you&rsquo;re tackling on your own or
a corporate initiative comprised of many development teams, releasing code to some version of &ldquo;production&rdquo; feels good and demonstrates tangible progress both to yourself
and to anyone who&rsquo;s interested in the project&rsquo;s outcome. If you&rsquo;ve ever spent weeks trying to design a system or library perfectly only to lose interest before even
getting started, lack of tangible progress could be to blame. In some ways, this is almost a trick or a hack - it&rsquo;s as useful for us to demonstrate progress to ourselves as it is
to anyone else!</p>
<h4 id="we-learn-about-the-efficacy-of-our-existing-design-and-implementation">We learn about the efficacy of our existing design and implementation</h4>
<p>By consistently adding functionality to the system by modify each component within it, we&rsquo;re able to easily understand how well we have done with design fundamentals like
encapsulation, decoupling, and separation of concerns. Difficulty implementing a stripe into the system is a signal that our design may be missing some crucial element, or possibly
that our implementation has not done a good job of realizing the design.</p>
<p>Implementing tests as we complete each stripe allows us to ensure that the important properties of each component remain testable as we&rsquo;re making continued changes within
the system.</p>
<p>Writing documentation for public interfaces and system-level concepts forces us to be able to explain why we&rsquo;ve made the decisions that we have and how they fit together
to provide the functionality that we&rsquo;re aiming for.</p>
<p>Paying attention to the linter and compiler warnings ensures that we&rsquo;re not relying upon shaky foundations for any of the core components or libraries that comprise
the foundation of our system.</p>
<p>Really, this is all basic software engineering stuff, but holding ourselves to it for <em>every</em> stripe that we implement provides some structure to the way that we work:
we don&rsquo;t necessarily have to write documentation or clean up a compiler warning immediately when we write a new public API, but we do require ourselves to do it before
we will consider our current stripe complete. This makes each stripe act like a sort of checkpoint that guides us to follow the best practices that we know are important,
but that can also easily fall by the wayside as we get swept up in the flow of implementation.</p>
<h2 id="example">Example</h2>
<p>So, I talked a lot about what striped development is and how it can benefit us, but what does this process really look like?</p>
<p>As referenced earlier in the post, I was originally inspired to write this post by another author&rsquo;s explanation of the implementation strategy they used to implement
a compiler. Recently, I have been working on <a href="https://github.com/jkaye2012/jackal">a compiler of my own</a> using the striped development methodology. The language is called
Jackal. This is a very young project (I&rsquo;ve completed only one pass through the development loop), but the structure of a compiler is very well-suited to this style of development,
so a discussion of Jackal&rsquo;s initial development is a real-world way to showcase how striped development works in practice.</p>
<h3 id="design-1">Design</h3>
<p>First, we have to come up with an initial design that we can work off of.
For a compiler, this is mostly done for us as we can leverage the vast amount of literature and public works
available to understand a good starting point. My first stripe design ended up extremely simple:</p>

<hr />
<img  src="/images/striped-dev-components.png"   title="Junior&#39;s first compiler design. Isn&#39;t it cute?"  />
<hr />
<p />

<p>You can probably tell that I&rsquo;m not a compiler design expert, but I do know that I&rsquo;ll need a way to <a href="https://en.wikipedia.org/wiki/Lexical_analysis">lex</a> and
<a href="https://en.wikipedia.org/wiki/Parsing">parse</a> the source code, transform it into an <a href="https://en.wikipedia.org/wiki/Intermediate_representation">intermediate representation</a>,
<a href="https://en.wikipedia.org/wiki/Type_system#Type_checking">type-check</a> the IR, and finally <a href="https://en.wikipedia.org/wiki/Code_generation_(compiler)">generate machine code</a>.
Critically, this design is missing at least one component that will be a strict requirement before the compiler can be called complete: an
<a href="https://en.wikipedia.org/wiki/Optimizing_compiler">optimizer</a>. While we&rsquo;re likely missing more than just this one component in reality, this showcases the idea that
our design need not be complete during any individual phase of striped development. I know that I&rsquo;ll need an optimizer in the future, but I don&rsquo;t yet have the context
or knowledge to reasonably implement this component into my stripes, so I&rsquo;ve purposefully delayed those decisions to a future phase.</p>
<p>It&rsquo;s also worth highlighting that this initial design is <em>very</em> high level. It specifies only the least-granular components within the system, providing no detail yet
as to how each of these components might be implemented or what the APIs between them should look like. This early lack of detail is another hallmark of the striped
development methodology. As we begin to implement and learn more about how our system works, we will continuously update this design to add more detail as decisions
begin to solidify. Creating a design diagram just to change it every week is probably not particularly useful, but that doesn&rsquo;t mean that we shouldn&rsquo;t create any diagram
at all: regardless of what specific decisions I make within each of these 5 components, it&rsquo;s highly unlikely that any of them will go away entirely, and the data flow
between them is likely to remain stable as well.</p>
<p>As development of the system continues, this diagram will evolve and expand to contain more granular detail. It can be thought of as a sort of evolving map, both
documenting where we are currently and where we aim to go in the future.</p>
<h3 id="striping-1">Striping</h3>
<p>With our initial design complete, we can now move on to the second phase: selecting our stripes. I expect this project to be even more iterative than usual
due to my inexperience with language design and my desire to experiment with different ideas, so I decided to keep the forecasting to a minimum and define only three
stripes to start:</p>
<ol>
<li>Use a tiny language definition to implement all 5 components and see them work together end-to-end</li>
<li>Replace the tiny language definition with an <a href="https://en.wikipedia.org/wiki/Minimum_viable_product">MVP</a> for how I expect Jackal to look</li>
<li>Implement integrated language tooling for the MVP</li>
</ol>
<p>It&rsquo;s important to highlight that I decided on these stripes before starting <em>any</em> development. These stripes now comprise a plan for how I&rsquo;m going to implement the
system and what sort of considerations I should be taking into account during each of the implementation phases. While working on each stripe, I&rsquo;ll have a very specific
goal to complete, but I&rsquo;ll also have a picture of where I&rsquo;ll be going in the future. Since the cycle returns us to the striping phase after each implementation phase is
complete, we should always have our next three stripes selected so that we have a good idea of what&rsquo;s to come.</p>
<p>We can visualize stripes as a sort of overlay atop our design from the previous phase:</p>

<hr />
<img  src="/images/striped-dev-stripes.png"   title="Stripes are completed left to right"  />
<hr />
<p />

<p>Let&rsquo;s briefly consider how these stripes relate to one another and how they help us achieve our greater goal:
a full programming language working from source code to running executable.</p>
<h4 id="first-stripe">First stripe</h4>
<p>The first stripe exists to give us a strong base of code to work within. The language I chose to use as a model for implementing each component had nothing to do
with the actual Jackal language that will eventually be implemented using these components, but was simple enough that it allowed me to focus instead on the overall
structure and functionality <em>within</em> each component. I was able to explore different decisions around how those components might interact with one another and how
they should interact with the outside world (an application of <a href="/posts/imperative-shell-functional-core/">Imperative Shell, Functional Core</a>, which I plan to post
about in the future).</p>
<h4 id="second-stripe">Second stripe</h4>
<p>The second stripe exists for two reasons:</p>
<ol>
<li>It provides us with a working version of the language that we can begin to experiment with</li>
<li>It tests our implementation of the design: how difficult will it be to swap the underlying language out from our components?</li>
</ol>
<p>The first is more important from a delivery perspective, while the second is more important from a development perspective. Regardless of which we care more
about, this single phase allows us to understand both simultaneously.</p>
<p>This also demonstrates the &ldquo;frequent deployment&rdquo; concept that we touched on in the
striping definition: getting an initial MVP version of the language working will be a huge motivating factor in the language&rsquo;s continued development by making
it a real working system that I can iterate on instead of a theoretical idea that I&rsquo;m thinking about.</p>
<h4 id="third-stripe">Third stripe</h4>
<p>Finally, the third stripe may seem somewhat out of place, but I&rsquo;ve selected it primarily due to my goals for the language and because I know that having
integrated tooling this early in the development process will make writing Jackal code feel much more &ldquo;real&rdquo; than it would without this type of
functionality.</p>
<p>One of Jackal&rsquo;s primary goals is to make as much tooling as possible first-class and vended with the compiler itself. The ultimate success
would be that no language-specific dependencies need to be installed to be productive with the language (accomplished by integration with language-agnostic dependencies,
such as <a href="https://tree-sitter.github.io/tree-sitter/">Tree-sitter</a> and a <a href="https://microsoft.github.io/language-server-protocol/">Language Server Protocol</a> client).</p>
<p>As I&rsquo;m developing the language, I want to be incrementally writing code in the language itself, whether that&rsquo;s the standard library or other
packages that I would intend to distribute independently from the core language in the future. Without basic niceties like syntax highlighting, auto-complete,
auto-formatting, and integrated debugging, I won&rsquo;t have a good feel for what working with the language will <em>actually</em> be like.</p>
<p>With the three stripes defined, I now have a roadmap for what my focus will look like as I&rsquo;m making progress on the project. I can look forward to the completion
of each stripe to demonstrate progress to myself and to release basic versions of the language to anyone who cares about it (no one at all, for now).</p>
<h3 id="implementation-1">Implementation</h3>
<p>As this isn&rsquo;t meant to be a post about how to write code, there isn&rsquo;t all that much to say about the implementation phase. We have an idea of the components that we need
to implement and how those components relate to each other, so this process is about translating those ideas into code that is simple, efficient, and will remain
easy to change as we continue to work within the system. How we approach each of these implementation decisions
is a process of its own; though we could in theory apply striped development to each individual component within the design, I&rsquo;ve found this to be more overhead
than it&rsquo;s worth in all but the most complex cases.</p>
<p>I can provide one very specific example of this type of decision: the introduction of <a href="https://github.com/jkaye2012/jackal/blob/main/util/source_location.hpp">source locations</a>
into the lexer. Without this concept, creating user-friendly error messages, even with such a tiny language, was already becoming cumbersome and error-prone.
By implementing source locations, which automatically tag each lexed token with metadata about its context within the original source file, compile-time error
messages now essentially write themselves. I&rsquo;m sure this source location concept is going to have to be greatly improved as the language continues to evolve,
but for the time being it&rsquo;s a great tool that will make development of the actual language MVP much less painful.</p>
<p>If you&rsquo;re interested in more depth on Jackal&rsquo;s first stripe (and a more in-depth explanation of my goals for the language in general), you can take a look at
<a href="https://github.com/jkaye2012/jackal/blob/main/blog/intro.md">the introductory summary</a> for the language. There are compilation units for most of the components presented
in the initial design:</p>
<ul>
<li><a href="https://github.com/jkaye2012/jackal/tree/main/lexer">Lexer</a></li>
<li><a href="https://github.com/jkaye2012/jackal/tree/main/parser">Parser</a></li>
<li><a href="https://github.com/jkaye2012/jackal/tree/main/ast">Abstract syntax tree</a></li>
<li><a href="https://github.com/jkaye2012/jackal/tree/main/codegen">Code generation</a></li>
</ul>
<p>It&rsquo;s obviously not important to understand each of these in any depth, but it may be interesting to look at the public interfaces for each component and how they
interact with one another. The implementation is quite simple right now, but I plan on keeping the repository up to date with more detailed information on how
designs and implementations were required to change with each subsequent stripe, showcasing how we can achieve a robust and stable design through iterative
thought and experimentation.</p>
<p>You may have noticed that the list of compilation units is missing an implementation for the semantic analysis (type-checking) component in the initial design.
The language I used to construct the basic compiler infrastructure was
untyped (all values were numbers), meaning that there wasn&rsquo;t a realistic way to understand if the decisions being made within an semantic analyzer were correct or useful.
As usual with striped development, embracing the iterative nature of the process means that it&rsquo;s okay to miss a subset of the overall design on the first pass so long as
we either update the design or implement the component in a subsequent phase. Striped development isn&rsquo;t meant to be restrictive or prescriptive, it&rsquo;s meant to give us
context for our work and a plan that we can follow to accomplish our goals.</p>
<h2 id="conclusion">Conclusion</h2>
<p>Striped development is a simple way to iterate on complex software projects. It can be used to design new systems from scratch, improve existing systems,
or even act as a general development methodology for a team. It embraces the uncertainty inherent in system design and implementation. It provides a basic
structure to help us constrain the difficult process of designing and implementing system-wide changes.</p>
<p>Give it a try sometime. I&rsquo;d love to know what you think!</p>

      </div>
      
      <div class="post">
        <div class="post-heading">
          <h1><a href="https://jkaye2012.github.io/posts/blog-genesis/">Creating a development blog</a></h1>
          <span>Dec 13, 2020</span>
        </div>
        
<p>
Welcome to the inaugural post of Organizing Chaos!</p>
<p>
I&#39;m the type of person who loves to tinker with new pieces of technology. Recently, I&#39;ve been experimenting with a few different
technical ideas that I thought were worth writing about (stay tuned for future posts ðŸ˜‰), so naturally I started to get excited about
the prospect of setting up a personal development blog for myself. After a weekend of research and experimentation, I&#39;ve arrived at a
very simple (yet effective!) setup that I&#39;m quite happy with.</p>
<p>
The remainder of this post will describe the open-source tools and workflow that I&#39;m using to create this blog, including a complete
example to generate the post that you&#39;re reading right now. How meta!</p>
<div id="outline-container-headline-1" class="outline-2">
<h2 id="headline-1">
Requirements
</h2>
<div id="outline-text-headline-1" class="outline-text-2">
<p>
  Before building something, it&#39;s always important to consider the basic requirements for solving the problem at hand. For this personal
  development blog, my basic requirements were simple. The most important things to me were that my setup should be:</p>
<ul>
<li>
<p>For the author:</p>
<ul>
<li>Simple: writing a blog isn&#39;t rocket science, and I don&#39;t need anything fancy. Above all else, the setup should be easy to understand and work with.</li>
<li>Efficient: when writing individual posts, the author shouldn&#39;t have to worry about the &#34;blogging framework&#34;. The ideal workflow is to write a post and publish it!</li>
</ul>
</li>
<li>
<p>For the user:</p>
<ul>
<li>Pretty: while it&#39;s unlikely that I&#39;ll design a visual masterpiece, the blog should look nice on both desktop and mobile displays.</li>
<li>No-nonsense: when viewing the blog&#39;s index or any individual post, the reader should have a consistent, no-frills experience. Someone visiting this blog is probably
here to read a post, not opt-in to cookies or sign up for a newsletter.</li>
</ul>
</li>
</ul>
<p>While these are admittedly very high-level and simplistic requirements, they provide enough context to get started with a search for a solution. We&#39;re out to build
  something that&#39;s easy to use and understand, looks nice, doesn&#39;t get in the way of our readers, and that&#39;s optimized for efficiency of writing individual blog posts.</p>
</div>
</div>
<div id="outline-container-headline-2" class="outline-2">
<h2 id="headline-2">
Site generation
</h2>
<div id="outline-text-headline-2" class="outline-text-2">
<p>
  Looking at our list of requirements, right away it seemed to me that static site generation was going to be a good route to pursue. In general, I&#39;m a big fan of simple
  websites (after all, why should we use JavaScript if we&#39;re not really doing anything interactive?), and static site generation is a simple way to build a simple site.
  Unfortunately, deciding <em>which</em> static site generator to use is not necessarily so simple. There are a plethora of options available, and many of the differences between
  them are minor. Because I&#39;m not interested in using JavaScript for this blog, the choice ultimately boiled down to two contenders:</p>
<ol>
<li><a href="https://jekyllrb.com/">Jekyll</a>, the veteran mainstay</li>
<li><a href="https://gohugo.io/">Hugo</a>, a more modern take on Jekyll&#39;s core ideas</li>
</ol>
<p>The TL;DR for the rest of this section is: I picked Hugo. There&#39;s a complete example of what a Hugo site looks like and some very basic usage examples in the last section
  of the post. The important thing to know about the Hugo choice is that, after less than an hour of minor theme modification, the blog is now at the point where authoring a new
  post is as simple as writing a single file containing the post&#39;s contents.</p>
<p>
  If you don&#39;t care why I chose Hugo over Jekyll, <a href="#Editing">you can skip straight to the next section</a>.</p>
<p>
  At first, I thought I was going to end up going with Jekyll. All things equal, I usually prefer the more established of two comparable technologies. In this case, however,
  Hugo ended up winning out. There were a few reasons for this, but the biggest factor for me was the ease of finding, understanding, and modifying themes. Despite a huge number
  of available themes, I struggled to find a Jekyll theme that had a base look that I liked enough to want to adapt for my own blog. I eventually found Hyde, but was quickly
  disappointed with the configuration options of the theme. In general, I found myself frustrated with Jekyll; it felt somehow difficult to understand and to work with.
As this seemed to be violating my simplicity requirement, I decided to give Hugo a try.</p>
<p>
  While I had spent almost three hours failing to get Jekyll looking decent and functioning properly, I had a Hugo site up and running in under an hour (using my own form of
  the <a href="https://www.github.com/jkaye2012/strange-case">strange-case</a> theme) and was able to start writing some content. A simple, easy to understand framework is the most important requirement to me, so Hugo won the day.</p>
<p>
  Interestingly, after getting a bit more familiar with both tools over the past few days, I have a feeling that Hugo might actually be <em>more</em> complex than Jekyll is; however,
  Hugo does a fantastic job of hiding this complexity. This allows basic users to take advantage of simple subsets of its functionality, while also providing power users with
  more flexibility for advanced use cases. I don&#39;t know the details of the framework very well, but on the surface, it seems to be quite well-designed from at least that perspective.</p>
<p>
  If you&#39;re interested in seeing just how easy it was for me to modify the base theme for my purposes, you can take a look at <a href="https://github.com/jkaye2012/strange-case/commit/203d4932183de989a3f725458a60307b12c1c3e5">my first theme modification</a>, wherein I added the
  horizontal social icons section to the blog&#39;s sidebar.</p>
</div>
</div>
<div id="outline-container-Editing" class="outline-2">
<h2 id="Editing">
Authoring a post
</h2>
<div id="outline-text-Editing" class="outline-text-2">
<p>
  As mentioned in the previous section, after downloading Hugo and making my theme modifications, the only thing left to do is actually write a post.</p>
<p>
  For editing of all kinds, I am a die-hard <a href="https://www.gnu.org/software/emacs/">Emacs</a> user. <a href="https://orgmode.org/">Org-mode</a> is one of the most popular Emacs features, and for good reason: it&#39;s amazing for managing structured
  text. Hugo supports org-mode as one of its markdown formats meaning that, bar a few minor idiosyncrasies,
  posts will &#34;just work&#34; when written in a .org file within the blog&#39;s Git repository. Given all of org-mode&#39;s powerful features, this is a huge win for efficiency
  while writing each individual posts.</p>
<p>
  Emacs and org-mode certainly aren&#39;t for everyone. The learning curve is steep and some of the edges are rough compared to more modern tooling (though many of the recently-developed
  Emacs packages are nothing short of amazing). That being said, I thought I&#39;d provide a motivating example that I think goes to show a little bit of the power that Emacs provides
  its devoted users.</p>
<div id="outline-container-headline-4" class="outline-3">
<h3 id="headline-4">
Org-babel
</h3>
<div id="outline-text-headline-4" class="outline-text-3">
<p>
   One of the reasons that writing org files is a great choice for a development blog is <a href="https://orgmode.org/worg/org-contrib/babel/">org-babel</a>. An early journal paper describes babel as a
   &#34;multi-language computing environment for literate programming&#34;, which is a very apt (if not so concise) description. Babel allows the author to <em>weave</em> executable code blocks directly
   within their prose. Individual blocks can be run and re-run iteratively on the author&#39;s machine, and the entirety of the code from within a document can be extracted (called
   <em>tangling</em>) into a final executable file.</p>
<p>
   For a development blog, code examples are extremely important; this makes Babel an incredible tool to have at your disposal as a blog author! For example, as I&#39;m writing
   this post, I can embed a simple block of Haskell code. When I press a key in my editor, the block is executed <em>directly within the post</em>, meaning that I never have to stop
   writing my blog post to write my code or execute my examples! After the results block I&#39;ll include a GIF of the process so that you can see how it works.</p>
<div class="src src-haskell">
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#a6e22e">putStrLn</span> <span style="color:#e6db74">&#34;Hello, Hugo! And again&#34;</span></code></pre></div>
</div>
<pre class="example">
Hello, Hugo! And again
</pre>
<p>
   The GIF, as promised (you may need to click it to read the text):</p>
<p>
   <img src="/gifs/org-babel-simple.gif" alt="/gifs/org-babel-simple.gif" title="/gifs/org-babel-simple.gif" /></p>
<p>
   This example only scratches the surface of the functionality provided by org-mode and org-babel. If you&#39;re interested to learn more about these, please let me
   know; I do plan on writing a more in-depth post on Org in the future.</p>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-5" class="outline-2">
<h2 id="headline-5">
Hosting
</h2>
<div id="outline-text-headline-5" class="outline-text-2">
<p>
  One of the nice things about using a static site generator is that your hosting options are wide open. Since you&#39;re reading this, you&#39;re probably aware that I ended up
  deciding on GitHub Pages; I like GitHub as a collaboration platform, and have read some nice blogs on GitHub Pages in the past, so Pages was the first option I thought to
  try for hosting my site. This turned out to be a good decision, as hosting a static site on GitHub Pages couldn&#39;t be much easier.</p>
<p>
  It&#39;s possible that there are better hosting options, but Pages is free to use and I literally had the site up in around two minutes, so I didn&#39;t feel a need to look
  much further.</p>
</div>
</div>
<div id="outline-container-headline-6" class="outline-2">
<h2 id="headline-6">
Putting it all together
</h2>
<div id="outline-text-headline-6" class="outline-text-2">
<p>
  The only thing left is to show an example for how all of this works!</p>
<p>
  Here&#39;s the complete authoring and deployment process that I used to generate this post:</p>
<div class="src src-bash">
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">cd ~/git/blog-hugo
hugo new posts/blog-genesis.org <span style="color:#75715e"># Create the post file</span>
emacs -nw content/posts/blog-genesis.org <span style="color:#75715e"># Write the post</span>
hugo <span style="color:#75715e"># Build the site</span>
<span style="color:#75715e"># Deploy to GitHub</span>
cd public
git commit -m <span style="color:#e6db74">&#34;Made a change to the blog&#34;</span>
git push origin master</code></pre></div>
</div>
<p>
  <a href="https://www.github.com/jkaye2012/blog-hugo">This blog&#39;s source code</a> is a very simple example of what you might expect a statically-generated blog to look like.</p>
<p>
  <a href="https://github.com/jkaye2012/blog-hugo/blob/master/content/posts/blog-genesis.org">The source code for this post</a> should be very easy to understand as well.</p>
</div>
</div>
<div id="outline-container-headline-7" class="outline-2">
<h2 id="headline-7">
Closing notes
</h2>
<div id="outline-text-headline-7" class="outline-text-2">
<p>
  Getting a personal blog up and running is a fun project that I would recommend to any developer who has an interesting in writing.
  The open-source tools in this space are easy to use and provide a great experience!</p>
<p>
  To those of you who stuck around, I hope you enjoyed the first post. I hope to write on more interesting technical topics in the near
  future, so stay tuned!</p>
</div>
</div>

      </div>
      

      <div class="text-center">
        
      </div>

    </div>
    <div class="col-sm-1 col-md-3 col-md-4">
    </div>
  </div>
</div>







<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js"></script>

<script src="https://jkaye2012.github.io/js/bootstrap.min.js"></script>

</body>
</html>
